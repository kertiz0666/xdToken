/**
 * xdTok - Enhanced Hybrid Token Generator v1.0.1
 * Generates sortable, base36 encoded tokens (6-96 chars) suitable for unique IDs.
 * Structure: [Timestamp(9)][Instance(4)][Counter(3)][Random(...)]
 * Optimized for high throughput and uniqueness across instances.
 * Includes UMD wrapper for compatibility with Node.js, AMD, and browser globals.
 * License: MIT
 * Copyright (c) 2024 Jakub Åšledzikowski <jsledzikowski.web@gmail.com>
 */
(function (root, factory) {
  // UMD Wrapper: Export module based on environment
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if (typeof module === 'object' && module.exports) {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window or self)
    root.xdTok = factory();
  }
}(typeof self !== 'undefined' ? self : this, function () {
  // --- Start of original xdTok IIFE logic ---
  const xdTokGenerator = (() => {
    // --- Internal State ---
    let lastTimestamp = -1; // Tracks the last used timestamp in milliseconds
    let counter = 0;        // Counter for operations within the same millisecond

    // --- Configuration ---
    const base = 36;         // Alphabet size (0-9, a-z)
    const tsLen = 9;         // Length of Timestamp part (base36 ms from epoch)
    const instanceLen = 4;   // Length of Instance ID part
    const counterLen = 3;    // Length of Counter part
    const fixedPartLen = tsLen + instanceLen + counterLen; // Total length of non-random part: 16
    const maxCounter = base ** counterLen - 1; // Max counter value (36^3 - 1 = 46655)

    // --- Helper Functions ---

    /**
     * Generates a random base36 string of a given length.
     * Prefers crypto.getRandomValues in browsers if available for better randomness,
     * otherwise falls back to Math.random.
     * @param {number} len The desired length of the random string.
     * @returns {string} The generated random string.
     */
    const generateRandom = (len) => {
      if (len <= 0) return ''; // Handle zero or negative length

      // Explicitly check for browser's crypto API
      const useCrypto = typeof window !== 'undefined' && window.crypto && window.crypto.getRandomValues;

      if (useCrypto) {
        // Use Web Crypto API (more secure source of randomness)
        const arr = new Uint8Array(len);
        window.crypto.getRandomValues(arr);
        // Map byte values to base36 characters.
        // Note: `val % base` introduces a slight bias as 256 is not perfectly divisible by 36.
        // This bias is generally considered negligible for unique ID generation.
        return Array.from(arr, val => '0123456789abcdefghijklmnopqrstuvwxyz'[val % base]).join('');
      } else {
        // Fallback using Math.random (less secure, suitable for Node.js without 'crypto' module or older browsers)
        let result = '';
        for (let i = 0; i < len; i++) {
          result += Math.floor(Math.random() * base).toString(base);
        }
        return result;
      }
    };

    /**
     * Converts a number to a base36 string, padded with leading zeros to meet the specified length.
     * @param {number} value The number to convert.
     * @param {number} length The target length of the output string.
     * @returns {string} The padded base36 string.
     */
    const toBase36 = (value, length) => value.toString(base).padStart(length, '0');

    // --- Instance Identifier (computed once at initialization) ---
    // This helps differentiate tokens generated by different processes or browser tabs
    // running concurrently, reducing the chance of collision within the same millisecond.
    const instancePart = (() => {
      // Generate a random part first, used either entirely or partially.
      const randomPart = generateRandom(instanceLen);

      // Try to incorporate the process ID in Node.js environments for better differentiation.
      if (typeof process !== 'undefined' && process.pid) {
        const pidPart = process.pid.toString(base);
        // Combine the base36 PID and the random string, then take the last `instanceLen` characters.
        // This mixes predictable (PID) and random data.
        return (pidPart + randomPart).slice(-instanceLen);
      }

      // In browsers or environments without process.pid, use the purely random data.
      // If window.crypto was available, this randomPart is cryptographically generated.
      return randomPart;
    })();

    // --- Main Token Generator Function ---
    /**
     * Generates a hybrid, base36 encoded token with a specified length.
     * @param {number} [requestedLength=16] The desired token length (must be between 6 and 96). Defaults to 16.
     * @returns {string} The generated base36 token.
     * @throws {Error} If the requestedLength is outside the allowed range [6, 96].
     */
    return (requestedLength) => {
      // Set default length if none provided, ensure it's a number, and validate the range.
      requestedLength = typeof requestedLength === 'number' ? Math.floor(requestedLength) : fixedPartLen;
      if (requestedLength < 6 || requestedLength > 96) {
        throw new Error("Token length must be between 6 and 96 characters.");
      }

      // Get the current time in milliseconds since the Unix epoch.
      const now = Date.now();

      // --- Time and Counter Management ---

      // Handle clock moving backwards scenario.
      if (now < lastTimestamp) {
        // Log a warning. Generating tokens based on a timestamp earlier than the previous one
        // breaks strict monotonicity. The generator continues, but this might indicate system issues.
        // We don't reset the counter here, allowing it to continue from where it was for the *previous* timestamp.
        // Using the new, earlier `now` timestamp with a potentially high counter value.
        console.warn(`Clock went back: ${now} < ${lastTimestamp}. Instance: ${instancePart}. Strict monotonicity broken.`);
        // NOTE: For critical monotonic systems, throwing an error or waiting might be preferred.
      } else if (now > lastTimestamp) {
        // Normal case: Time moved forward to a new millisecond.
        // Update the last timestamp and reset the counter for this new millisecond.
        lastTimestamp = now;
        counter = 0;
      }
      // If `now === lastTimestamp`, we are in the same millisecond, counter will just increment.

      // Check for counter overflow within the current millisecond.
      if (counter > maxCounter) {
        // This is extremely unlikely (requires > 46,656 calls/ms/instance) but handled defensively.
        console.warn(`Counter overflow detected at timestamp ${lastTimestamp}. Instance: ${instancePart}. Resetting counter. Collision risk increases slightly if overflow happens frequently.`);
        // Reset the counter to 0. The next token in this ms will have counter 0 again.
        counter = 0;
        // NOTE: Alternative strategies include waiting 1ms or throwing an error. Reset is simplest.
      }

      // Get the current counter value for *this* token, then increment the counter for the *next* call.
      const currentCounterValue = counter++;

      // --- Token Assembly ---

      // Convert timestamp and counter to padded base36 strings.
      const tsPart = toBase36(now, tsLen);
      const counterPart = toBase36(currentCounterValue, counterLen);

      // Combine the fixed parts of the token.
      const fixedPart = tsPart + instancePart + counterPart; // Always 16 chars

      // Calculate how much random padding is needed.
      const randomLen = requestedLength - fixedPartLen;

      // Construct the final token based on the requested length.
      if (randomLen >= 0) {
        // If requested length is 16 or more, append a random suffix.
        const randomPart = generateRandom(randomLen);
        return fixedPart + randomPart;
      } else {
        // If requested length is less than 16, truncate the fixed part from the right.
        // This preserves the most significant parts (timestamp).
        return fixedPart.slice(0, requestedLength);
      }
    };
  })();
  // --- End of original xdTok IIFE ---

  // Return the generator function so the UMD wrapper can export it
  return xdTokGenerator;
})); // End of UMD wrapper